---
layout: post
title: ðŸ”’ Security for Connected Objects
date: 2024-11-18
categories: [INSA]
image: /assets/covers/energy.png
---




# Descriptive Part

The goal of the security course was get a good understanding of the principles and challenges of security in various domains, the course was articulated around different aspects of security each focusing on unique challenges and methods to protect systems.

In the cryptography course, we explored how to secure information through mathematical encoding techniques to ensure data integrity, confidentiality, and authentication (RSA, AES, TLS...). We covered theorical concepts and real-world cryptographic algorithms.

In the course on side-channel attacks, we focused on how attackers can exploit unintentional information leaks (like power consumption or timing differences) to break cryptographic systems. This covered practical examples like "Flush and Reload" or "Prime and Probe" to know the risks and defenses in hardware systems.

In communication protocol security, we learned the basics on how to design and verify secure protocols for data exchange. We got introduced to threats like replay and impersonation attacks. In addition, we got a small introduciton on formal methods (ProVerif...) to prove that protocols are mathematically secure. 

The web application security module introduced us to vulnerabilities like SQL injection and cross-site scripting (the most common threats faced by websites).

Finally, reverse engineering microarchitectures taught us how to analyze hardware systems to understand their design and identify potential weaknesses. All theses courses where complemented by practical labs to better understand the concepts.

But that's not all, we also had a course and practical lab on quantum security that covered quantum security mechanisms like ...

# Technical Part

## Security Features of the Interdisciplinary Project

Security is a crucial aspect of all projects involving some sort of communication, especially in a Wireless Sensor Network where data integrity and confidentiality are essential.

### Context and Challenges

To add a bit of context on the matter, our interdisciplinary project aim to detect water leaks using a distributed network of sensors (WSN), each equipped with an ESP32 and a LoRa module for communication. These sensors transmit a payload consisting of metrics (frequency and harmonic data, timestamps, etcâ€¦) and edge computing analysis preliminary results (output of small machine learning models). Our LoRa module (SX1278) operate on frequencies ranging from 410MHz to 525MHz and is designed for low power consumption and limited bandwidth. Without any security features each sensor node is vulerable to every attack imaginable (replay attacks, data tempering, eavesdroppingâ€¦). Consequently it is necessary for the project to implement a security solution that protects data integrity and confidentiality without introducing too much overhead.

### Proposed Solution

We propose a lighweight security mechanism based on pre-shared symmetric keys that use AES-128 encryption: each sensor encrypts its data using AES in Cipher Block Chaining (CBC) mode with a unique and randomly generated Initialization Vector (IV) for every message. The IV is then transmitted with the actual message.

The issue with this method is that we have to transmitt the Initialization Vector with each message. Depending on the IV size (16 bytes usually) this can add significant overhead, and with LoRa (maximum packet size 256 byte) we can't afford it. This led me to think a new solution.

Instead of sending the whole Initialization Vector we can store a static decimated 14 byte version on each nodes and only send two randomly generated bytes to complete the IV. This solution alter AES security but this tradeoff is acceptable for the application. Moreover the Initialization Vector goal is to introduce some randomness in the cryptographic process in order to prevent replay attacks, but fortunately our application transmitt FFT data in its payload, but Fast Fourier Transformations induce significant chaos and randomness which results in the extremely low probability of message duplicata thus naturally tampering potential replay attacks.

14 bytes static IV section = strong entropy base
2 randomly generated additional IV bytes = ["salt"](https://fr.wikipedia.org/wiki/Salage_(cryptographie))
2 bytes = 2^16 = 65536 possible combinaisons which is acceptable for an embedded system
keep aes 16 bytes iv



### Implementation

In order to implement AES on the microcontroller we first thought about implementing AES in bare-metal without library as its not a particularly complex algorithm but we found TinyAES (https://github.com/kokke/tiny-AES-c), a lightweigh cross platform library.

Source code of the implementation: [light-encrypt](https://github.com/Lemonochrme/light-encrypt/tree/main)

```c
[Test Task] Original Message: Hello World
[Test Task] Encrypted Data:
04 b4 d0 b0 1a f1 c4 a6 94 95 b3 f2 6c 4a ee fd 82 2c 
[Test Task] Decrypted Message: Hello World

[Test Task] Original Message: Hello World
[Test Task] Encrypted Data:
78 d8 f3 74 04 7b fb 13 49 d2 f7 a8 65 36 a3 01 39 cc 
[Test Task] Decrypted Message: Hello World
```
In the demonstration above we can clearly see the entropy implemented by the IV, while the clear message is identical, the encrypted output is absolutely different. This mechanism effectively prevents replay attacks.








## Lab 1: Introduction to mbedTLS library

Objectives:
- Determine secured cryptographic parameters using current standards recommandations;
- Create our own Certification Authority (CA) called MSIoT CA to generate certificates for any
device;
- Generate key pairs for a device and generate a MSIoT CA-signed certificate;
- Simulate a man-in-the-middle attack to test several attack scenarios.

### Selection of RSA security parameters

Security parameters must be selected with respect to the standard see https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf

RSA in signature mode: encrypt private key, decrypt public key
*This is only for signature mode, we invert the public and private keys normally.*

> With the help of NIST SP 800-131Ar2, find recommanded parameters for RSA used in encryption
mode and signature mode.

len(n) >= 2048 bits (see Table 5)
SHA-2 512 bits (see Table 8)

After modifying CA-CERT.c accordingly and compiling/executing it we end up with the public, private key and the self signed (with the verification key-to be transmitted to other agents that want to verify the CA Certificate) certificate properlly generated.

> With the help of NIST SP 800-131Ar2, find recommanded DRBGs.

CTR_DRBG with AES-128, AES-192 and AES-256AES-256 or Hash_DRBG and HMAC_DRBG (Table 3)

DRGB: Discrete Random Byte Generator

### Experimentations


#### Creation of the Certification Authority

After modifying CA-CERT.c withe the aboved cited parameters and compiling/executing it we end up with the public, private key and the self signed (with the verification key-to be transmitted to other agents that want to verify the CA Certificate) certificate properlly generated.

```
.
â”œâ”€â”€ ca-cert
â”œâ”€â”€ CA-CERT.c
â”œâ”€â”€ CA-CERT.o
â”œâ”€â”€ ca.crt
â”œâ”€â”€ ca-signature-private-key.pem
â”œâ”€â”€ ca-signature-public-key.pem
â””â”€â”€ Makefile
```

#### Generation of the CSR

> Complete the preambule and mbedtls_x509write_csr_set_key

We had to copy what we did earlier on RSA to generate the new certificate signing request `device.csr`.

> Generation of the device certificate

```c
	/** Read RSA parameters **/	
	mbedtls_pk_parse_keyfile       (&skey, "/home/marin-muller/Bureau/TLS-LAB/1-CA-CERT/ca-signature-private-key.pem", NULL); 
	mbedtls_pk_parse_public_keyfile(&pkey, "/home/marin-muller/Bureau/TLS-LAB/1-CA-CERT/ca-signature-public-key.pem");

	if(mbedtls_pk_check_pair(&pkey,&skey)) 
	{
		printf("key-pair error\n");
		return 1;
	}
	mbedtls_x509write_crt_set_subject_key(&crt, &pkey);
	mbedtls_x509write_crt_set_issuer_key (&crt, &skey);
```
We retrieve private and public key and then we generate the device.crt.

#### Verification of the device certificate

```c
mbedtls_x509_crt_parse_file(&trust_ca  ,"/home/marin-muller/Bureau/TLS-LAB/1-CA-CERT/ca.crt");
mbedtls_x509_crt_parse_file(&device_ctr, "/home/marin-muller/Bureau/TLS-LAB/3-CA-SIGN/device.crt");
```

```bash
marin-muller@insa-21096:~/Bureau/TLS-LAB/4-DEVICE-VERIF$ ./device-crt-verif 
Well Done! Authentication succeeded
```

#### Man in the Middle

`device-a.c`:
```c
int main()
{
	if(setup_pipe()) {
		printf("Error generating pipe %s, exit\n",FIFO_NAME);
		return -1;
	}
	
	int fdchannel;
	if( (fdchannel = open(FIFO_NAME, O_WRONLY)) == -1) {
		printf("Error opening pipe %s, exit\n",FIFO_NAME);
		return -1;	
	}
	
	printf("[device A] Gathering Certificate...\n");
	FILE* fp = fopen( "/home/marin-muller/Bureau/TLS-LAB/3-CA-SIGN/device.crt", "rb" );
    char crt[BUFFER_LENGTH];
	fread(crt, BUFFER_LENGTH, 1, fp);
	fclose (fp);
	printf("[device A] Certificate: %s\n", crt);

	printf("[device A] Sending Certificate...\n");
	write(fdchannel, crt, BUFFER_LENGTH);

	printf("[device A] Sending \"HELLO, MY NAME IS ALICE\" to device B\n");
	char message[BUFFER_LENGTH] = "HELLO, MY NAME IS ALICE";
	write(fdchannel,  message, sizeof(message));
	
	return 0;
}
```

`device-b.c`:
```c
int main()
{
	if(setup_pipe()) {
		printf("Error generating pipe %s, exit\n",FIFO_NAME);
		return -1;
	}
	int fdchannel;
	if( (fdchannel = open(FIFO_NAME, O_RDONLY)) == -1) {
		printf("Error opening pipe %s, exit\n",FIFO_NAME);
		return -1;	
	}
	
	char recv[BUFFER_LENGTH];
	read(fdchannel,  recv, BUFFER_LENGTH);
	printf("[device B] Certificate received: %s\n", recv);

	mbedtls_x509_crt trust_ca, device_ctr;
	mbedtls_x509_crt_init(&trust_ca);
	mbedtls_x509_crt_init(&device_ctr);
	mbedtls_x509_crt_parse_file(&trust_ca  ,"/home/marin-muller/Bureau/TLS-LAB/1-CA-CERT/ca.crt");
	if (mbedtls_x509_crt_parse(&device_ctr, recv, 4096))
	{	
		printf("[device B] verification failed\n");
		return -1;
	}

	uint32_t verification_flags;
	if(mbedtls_x509_crt_verify(&device_ctr,
				    &trust_ca,
				    NULL,
				    NULL,
				    &verification_flags,
				    NULL, NULL ))
	{
		printf("[device B] verification failed\n");
	}else{
		printf("Well Done! Authentication succeeded\n");
		char message[BUFFER_LENGTH];
		read(fdchannel,  message, BUFFER_LENGTH);
		printf("[device B] Message received: %s\n",message);
	}

	return 0;
}
```

`attacker.c`:
```c
int main()
{
	int fdchannel_a;
	if( (fdchannel_a = open(FIFO_NAME_A, O_RDONLY)) == -1) {
		printf("Error opening pipe %s, exit\n",FIFO_NAME_A);
		return -1;	
	}
	
	char message[BUFFER_LENGTH];
	read(fdchannel_a,  message, BUFFER_LENGTH);
	printf("[attacker] Message captured: %s\n",message);
	
	
	int fdchannel_b;
	if( (fdchannel_b = open(FIFO_NAME_B, O_WRONLY)) == -1) {
		printf("Error opening pipe %s, exit\n",FIFO_NAME_B);
		return -1;	
	}
	char fake_message[BUFFER_LENGTH] = "I'M THE H4CK3R, MY NAME IS AL1C3";
	
	write(fdchannel_b,  message, BUFFER_LENGTH);
	printf("[attacker] Sending certificate\n");
	write(fdchannel_b,  fake_message, sizeof(fake_message));
	printf("[attacker] Sending fake message \"%s\"\n", fake_message);
	
	return 0;
}
```



## Security Features of the Interdisciplinary Project

Security is a crucial aspect of all projects involving some sort of communication, especially in a Wireless Sensor Network where data integrity and confidentiality are essential.

### Context and Challenges

To add a bit of context on the matter, our interdisciplinary project aim to detect water leaks using a distributed network of sensors (WSN), each equipped with an ESP32 and a LoRa module for communication. These sensors transmit a payload consisting of metrics (frequency and harmonic data, timestamps, etc...) and edge computing analysis preliminary results (output of small machine learning models). Our LoRa module (SX1278) operate on frequencies ranging from 410MHz to 525MHz and is designed for low power consumption and limited bandwidth. Without any security features each sensor node is vulerable to every attack imaginable (replay attacks, data tempering, eavesdropping...). Consequently it is *necessary* for the project to implement a security solution that protects data integrity and confidentiality without introducing too much overhead.

### Solution

We propose a lighweight security mechanism based on pre-shared symmetric keys that use AES-128 encryption: each sensor encrypts its data using AES in Cipher Block Chaining (CBC) mode with a unique and randomly generated Initialization Vector (IV) for every message. The IV is then transmitted with the actual message.

### Implementation

In order to implement AES on the microcontroller we first thought about implementing AES in bare-metal without library as its not a particularly complex algorithm but we found TinyAES (https://github.com/kokke/tiny-AES-c), a lightweigh cross platform library.


# Analytical Part






# Skills Matrix

| Skill | AE | Evaluation method |
| --- | --- | --- |
| Understand the fundamentals of security | 4 | Portfolio |
| Be able to identify security weaknesses in an IoT architecture | 3 | Portfolio |
| Be able to assess the impact of exploiting a security vulnerability in an IoT architecture | 3 | Portfolio |
| Be able to propose adequate security counter-measures | 3 | Portfolio |
| Knowing the main issues in security for IoT | 3 | Reports/Portfolio |
| Understand the terminology of security | 2 | Reports/Portfolio |
| Being able to have a critical look at the design of a system from a security point of view | 2 | Reports/Portfolio |
| Being able to understand a scientific article that explains a weakness or a security solution and to explain it | 2 | Reports/Portfolio |

1-level of application: follow-up of instructions or procedures  
2-level analysis: improvement or optimization of solutions or proposals  
3-level of control: design of programs or definitions of specifications  
4-level of expertise: definition of guidelines or strategies  
